# `Lambda`表达式
[捕获变量] (参数列表) 可选限定符->返回类型{
    //函数代码
}
```C++
int main()
{
    int x = 7;
    float y = 3.00;
    auto p = [x,y](int a,int b)->float{
        return x*y + a*b;
    };
    cout << p(10,20) << endl;
}
```
### 捕获外部变量
`lambda`表达式最前面的方括号的意义何在？其实这是`lambda`表达式一个很Hong要的功能，就是闭包。这里我们先讲一下`lambda`表达式的大致原理：每当你定义一个`lambda`表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个`lambda`表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的`lambda`表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为`lambda`捕捉块。
Lambda表达式可以捕获外面变量，但需要我们提供一个谓词函数（[capture list]在声明表达式最前）。类似参数传递方式：值传递、引入传递、指针传递。在Lambda表达式中，外部变量捕获方式也类似：**值捕获、引用捕获、隐式捕获。**
#### 值捕获
```c++
int a = 123;
auto f = [a] { cout << a << endl; }; 
f(); // 输出：123
a = 321;
f(); // 输出：123
```
值捕获和参数传递中的值传递类似，被捕获的值在Lambda表达式创建时通过值拷贝的方式传入，类中会相应添加对应类型的非静态数据成员。在运行时，会用复制的值初始化这些成员变量，从而生成闭包。因此**Lambda表达式函数体中不能修改该外部变量的值**； 因为函数调用运算符的重载方法是`const`属性的。同样，**函数体外对于值的修改也不会改变被捕获的值**。 想改动传值方式捕获的值，那么就要使用`mutable`。
```c++
int x = 10;
auto add_x = [x](int a) mutable
{
    x *= 2;
    return a + x;
};
cout << add_x(10) << endl;// 30
cout << "x = " << x << endl;// 10
```
因为一旦将`lambda`表达式标记为`mutable`，那么实现的函数调用运算符是非const属性的。
#### 引用捕获
```c++
int a = 123;
auto f = [&a]{a += 10;cout << a << endl;};
cout << a << endl;//123 因为没有调用f()
f();//133
a = 321;
f();//331
```
引用捕获的变量使用的实际上就是该引用所绑定的对象，因此引用对象的改变会改变函数体内对该对象的引用的值。 对于引用捕获方式，无论是否标记`mutable`，都可以在`lambda`表达式中修改捕获的值。
#### 隐式捕获
隐式捕获有两种方式，分别是:
- [=]：以值补获的方式捕获外部所有变量 
- [&]：表示以引用捕获的方式捕获外部所有变量。
```c++
int a = 5, b = 5;
    auto df = [=]()mutable
    {
        a += 1;
        b = 10;
        cout << a << " " << b << endl;
    }; // 值捕获
    auto rf = [&]
    {   a+= b;
        b = 10;
        cout << a << " "  << b << endl; }; // 引用捕获
    df();
    cout << a << endl;
    cout << b << endl;
    rf();
    cout << a << endl;
    cout << b << endl;
```

### 其他

| 捕获外部变量形式  |                                                 |
| :---------------- | :---------------------------------------------- |
| [ ]               | 不捕获任何变量（无参函数）                      |
| [变量1,&变量2, …] | 值(引用)形式捕获指定的多个外部变量              |
| [this]            | 值捕获this指针                                  |
| [=, &x]           | 变量x以引用形式捕获，其余变量以传值形式捕获     |
| [*this]           | 通过传值方式捕获当前对象                        |
| [&, x]            | 默认以引用捕获所有变量，但是x是例外，通过值捕获 |

>  既然只使用一次，那直接写全代码不就行了，为啥要函数呢？——因为lambda可以捕获局部变量

在上面的捕获方式中，注意最好不要使用`[=]`和`[&]`默认捕获所有变量。首先说默认引用捕获所有变量，你有很大可能会出现悬挂引用（Dangling references），因为引用捕获不会延长引用的变量的声明周期：

```c++
std::function<int(int)> add_x(int x)
{
	return [&](int a) {return x+a;};
}
```

因为参数`x`仅是一个临时变量，函数调用后就被销毁，但是返回的`lambda`表达式却引用了该变量，但调用这个表达式时，引用的是一个垃圾值，所以会产生没有意义的结果。如果通过传值的方式来解决上面的问题：

```c++
std::function<int(int)> add_x(int x)
{
    return [=](int a) { return x + a; };
}
```

使用默认传值方式可以便面悬挂引用问题.但是采用默认值捕获所有变量仍然有风险。例如当在类中捕获私有变量，当返回值为lambda表达式时，无法捕获到私有变量，但当指定为[=]时，会捕获到`this`指针的副本，当类已经调用析构函数，使用该指针仍然不安全.
