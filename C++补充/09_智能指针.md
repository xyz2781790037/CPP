# unique_ptr

1. 基于排他所有权模式：两个指针不能指向同一个资源
2. 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值
3. 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。
4. 在容器中保存指针是安全的

### 无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值

```c++
unique_ptr<string> p1(new string("I'm Li Ming!"));
unique_ptr<string> p2(new string("I'm age 22."));
	
cout << "p1：" << p1.get() << endl;
cout << "p2：" << p2.get() << endl;

p1 = p2;					// 禁止左值赋值
unique_ptr<string> p3(p2);	// 禁止左值赋值构造

unique_ptr<string> p3(std::move(p1));
p1 = std::move(p2);	// 使用move把左值转成右值就可以赋值了，效果和auto_ptr赋值一样

cout << "p1 = p2 赋值后：" << endl;
cout << "p1：" << p1.get() << endl;
cout << "p2：" << p2.get() << endl;
```

p1：0x5fe9b1b7f2b0
p2：0x5fe9b1b7f2e0
p1 = p2 赋值后：
p1：0x5fe9b1b7f2e0
p2：0

### 在 STL 容器中使用unique_ptr，不允许直接赋值

```c++
vector<unique_ptr<string>> vec;
unique_ptr<string> p3(new string("I'm P3"));
unique_ptr<string> p4(new string("I'm P4"));

vec.push_back(std::move(p3));
vec.push_back(std::move(p4));

cout << "vec.at(0)：" << *vec.at(0) << endl;
cout << "vec[1]：" << *vec[1] << endl;

vec[0] = vec[1];	/* 不允许直接赋值 */
vec[0] = std::move(vec[1]);		// 需要使用move修饰，使得程序员知道后果

cout << "vec.at(0)：" << *vec.at(0) << endl;
cout << "vec[1]：" << *vec[1] << endl;
```

### 支持对象数组的内存管理

```c++
// 会自动调用delete [] 函数去释放内存
unique_ptr<int[]> array(new int[5]);	// 支持这样定义
```

## 用法

### 1.构造

```c
class Test {
public:
	Test() { cout << "Test的构造函数..." << endl; }
	~Test() { cout << "Test的析构函数..." << endl; }

	void doSomething() { cout << "do something......" << endl; }
};


// 自定义一个内存释放其
class DestructTest {
	public:
	void operator()(Test *pt) {
		pt->doSomething();
		delete pt;
	}
};

// unique_ptr<T> up; 空的unique_ptr，可以指向类型为T的对象
unique_ptr<Test> t1;

// unique_ptr<T> up1(new T());	定义unique_ptr,同时指向类型为T的对象
unique_ptr<Test> t2(new Test);

// unique_ptr<T[]> up;	空的unique_ptr，可以指向类型为T[的数组对象
unique_ptr<int[]> t3;

// unique_ptr<T[]> up1(new T[]);	定义unique_ptr,同时指向类型为T的数组对象
unique_ptr<int[]> t4(new int[5]);

// unique_ptr<T, D> up();	空的unique_ptr，接受一个D类型的删除器D，使用D释放内存
unique_ptr<Test, DestructTest> t5;

// unique_ptr<T, D> up(new T());	定义unique_ptr,同时指向类型为T的对象，接受一个D类型的删除器D，使用删除器D来释放内存
unique_ptr<Test, DestructTest> t6(new Test);

```

### 2.**赋值**

```c++
unique_ptr<Test> t7(new Test);
unique_ptr<Test> t8(new Test);
t7 = std::move(t8);	// 必须使用移动语义，结果，t7的内存释放，t8的内存交给t7管理
t7->doSomething();
```

### 3.**主动释放对象**

```c++
unique_ptr<Test> t9(new Test);
t9 = NULL;
t9 = nullptr;
t9.reset();
```

### 4.**放弃对象的控制权**

```c++
Test *t10 = t9.release();// 释放所有权并返回原始指针
```

### 5.**重置**

```c
t9.reset(new Test);// 替换所管理的对象，并删除旧对象
```

# shared_ptr

如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或拷贝时，**引用计数**加1，当智能指针析构时，**引用计数**减1，如果计数为零，代表已经没有指针指向这块内存，那么我们就释放它！这就是 shared_ptr 采用的策略！

### 成员函数

| `operator*()` | 解引用指针 |
| ------------- | ---------- |
|               |            |

| `operator->()` | 访问对象成员 |
| -------------- | ------------ |
|                |              |

| `get()` | 返回原始指针 |
| ------- | ------------ |
|         |              |

| `use_count()` | 返回当前共享引用计数 |
| ------------- | -------------------- |
|               |                      |

| `unique()` | 是否是唯一拥有者（use_count 为 1） |
| ---------- | ---------------------------------- |
|            |                                    |

| `reset()` | 释放当前对象所有权 |
| --------- | ------------------ |
|           |                    |

| `reset(ptr)` | 拥有新对象 ptr |
| ------------ | -------------- |
|              |                |

| `swap(other)` | 与另一个 `shared_ptr` 交换资源 |
| ------------- | ------------------------------ |
|               |                                |